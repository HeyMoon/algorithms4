package com.dyh.algorithms4.chapter3;

/**
 * @author: dengyunhui
 * @datetime: 2021/7/15 00:38
 * @description: 用稀疏向量解决火车票售卖问题
 */
public class TrainTicketSaleProblem {

    /**
     * 火车有多个站，假设有 A B C D 四个站
     * 为了简单起见，我们先假设火车上只有一个座位，并且不能卖站票
     * 假设张三买了从 A 到 C 的票，现在李四要买从 B 到 D 的票，很显然李四买不了。
     * 那么我们要怎么建模表示这种场景呢？
     * 我们可以用一个 boolean 类型的数组表示各个站是否有人乘坐了
     * int[] stations = new int[4]
     * 我们假设 A B C D 分别对应于 stations 的下标为 0,1,2,3
     * 张三买了 从 A 到 C 的 票，那么 stations[0],stations[1],station[2] 都为 1.
     * 现在李四想买从 B 到 D 的票，我们只需要判断 stations[1],station[2],stations[3] 是否都是 1
     * 如果都是 0,则李四可以买；否则 李四不可以买
     *
     *
     * 上述场景是假设火车只有一个座位（并且不能卖站票的场景）。现在让我们假设火车上有两个座位，并且不能卖站票
     * 既然一个座位可以用一维数组表示，那么 两个座位是不是可以用二维数组表示呢？
     * int[][] seats = new int[2][4];
     * seats[0] 表示第一个座位，seat[1] 表示第二个座位
     *
     * 假设 张三买了从 A 到 C 的票
     * 那么张三买票的行为可以表示为：seats[0][0],seats[0][1],seats[0][2] 都为 1.
     *
     *
     * 假设李四买从 B 到 D 的票，那么李四的行为可以表示为 seats[1][1],seats[1][2],seats[1][3] 都为 1
     * 现在假设王五要来买 从 B 到 D 的票，要怎么判断是否有票卖给他呢？其实就是矩阵的乘法
     *  seats[2][4]                 buy
     * [1 1 1 0]   [0 1 1 1]
     * [0 1 1 1]                               = [0 1 1 1]
     *
     * 因为后面三个值都是 true 所以不能卖给王五
     *
     * 在实际中肯定不止只有二个座位，4个站台。我们假设有 N 个座位， M 个站台 (N 远远大于 M)
     * int[][] seats = new int[N][M];
     *
     * 所以其实买票就是向量 和 矩阵的乘法（行向量 * 矩阵），但是所需的时间和 N * M 成正比，因为 M 维结果向量中的每项都需要计算 N 次 乘法。
     * 因为需要存储整个矩阵，所以所需空间也和 N * M 成正比。
     *
     * 但是，这里的举证常常是稀疏的，即其中大多数项都是 0。
     *
     */


}
